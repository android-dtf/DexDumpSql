#!/usr/bin/env python
# Android Device Testing Framework ("dtf")
# Copyright 2013-2015 Jake Valletta (@jake_valletta)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""Search across framework or application DEX databases"""

import dtf.properties as prop
import dtf.logging as log
from dtf.module import Module

import os
import os.path
import re

import sqlite3
from argparse import ArgumentParser
from os import listdir

import DexDb
import Utils

TAG = 'dexsearch'

FILTER_APPS = 'apps'
FILTER_FRAMEWORKS = 'frameworks'

DEFAULT_FILTERS = [FILTER_APPS, FILTER_FRAMEWORKS]

class dexsearch(Module):

    """Module class for searching DEX databses"""

    about = 'Search DEX databases.'
    author = 'Jake Valletta (jakev)'
    health = 'beta'
    name = 'dexsearch'
    version = '1.0.0'

    def usage(self):

        """Usage message"""

        print "dexsearch v%s" % self.version
        print ""
        print "Search modes:"
        print "    [c]lass      Search for class."
        print "    [f]ield      Search for field."
        print "    [m]ethod     Search for method."
        print "    [s]tring     Search for string."
        print ""

        return 0

    @classmethod
    def validate_filters(cls, filters):

        """Confirm filters are correct"""

        if filters is None:
            return DEFAULT_FILTERS

        split_filters = filters.split(',')

        # Validate filter
        for filt in split_filters:
            if filt not in DEFAULT_FILTERS:
                log.e(TAG, "Invalid filter option: %s" % filt)
                return None
            log.d(TAG, "Adding filters: %s" % filt)

        return split_filters

    @classmethod
    def get_valid_dbs(cls, path):

        """Get valid dbs, return a list"""

        db_list = list()

        for db_file in os.listdir(path):

            if not re.match(".*\.db$", db_file):
                continue

            db_path = "%s/%s" % (path, db_file)

            if Utils.get_file_size(db_path) <= 0:
                log.e(TAG, "0 Byte database detected: %s" % db_path)
                continue

            db_list.append(db_path)

        return db_list

    @classmethod
    def search_db(cls, db_name, config):

        """Perform search"""

        search_class_name = config['class_name']
        search_method_name = config['method_name']
        string_pattern = config['string_pattern']
        show_fields = config['show_fields']
        show_methods = config['show_methods']
        field_contains = config['field_contains']
        file_mode = config['file_mode']
        exact = config['exact']
        mode = config['mode']

        method_search = False

        log.d(TAG, "Doing : %s" % (db_name))
        class_list = list()

        if search_method_name is not None:
            method_search = True
        elif string_pattern is not None:
            string_search = True

        conn = sqlite3.connect(db_name)

        if string_search:

            conn.text_factory = str
            string_matches = list()

            try:
                pattern = re.compile(string_pattern, re.UNICODE)
            except Exception as inst:
                log.e(TAG, "Unable to parse pattern: %s" % inst)
                return -2

            m_cursor = conn.cursor()
            msql = ('SELECT name '
                    'FROM strings')

            for line in m_cursor.execute(msql):

                string_name = line[0]

                if re.search(pattern, string_name):
                    string_matches.append(string_name)

            if len(string_matches) > 0:
                print "Match(es) in %s" % db_name
                for match in string_matches:
                    print "  %s" % match
            return 0

        cursor = conn.cursor()

        sql = ('SELECT id, name, access_flags, superclass '
               'FROM classes')

        for cls_id, cls_name, access_flags, superclass in cursor.execute(sql):

            if method_search:

                method_matches = list()

                m_cursor = conn.cursor()
                msql = ('SELECT name '
                        'FROM methods '
                        "WHERE class_id=%d" % cls_id)

                for method_name in m_cursor.execute(msql):

                    if method_name[0] == search_method_name:
                        method_matches.append([cls_name, method_name[0]])

                if len(method_matches) > 0:
                    print "Match(es) in '%s':" % db_name

                    for match in method_matches:
                        print "   %s->%s" % (match[0], match[1])

            else:
                if exact:
                    if cls_name == search_class_name:
                        class_list.append(cls_name)
                else:
                    if cls_name.find(search_class_name) != -1:
                        class_list.append(cls_name)

        if not method_search and len(class_list) != 0:
            if not file_mode:
                print "[+] In database: %s" % (db_name)
            for n_class in class_list:
                if file_mode:
                    if mode == 'frameworks':
                        dex_db_dir = '.dbs/frameworkdexdbs/'
                        tmp_fw_file = db_name.replace(dex_db_dir, "")
                        framework_file = tmp_fw_file.replace(".db", "")

                        unframework_dir = prop.get_prop("Local",
                                                        "unframework-dir")
                        dotted_path = n_class.replace(".", "/")
                        file_name = ("%s/%s/%s.smali"
                            % (unframework_dir, framework_file, dotted_path))

                    else:
                        dex_db_dir = '.dbs/appdexdbs/'
                        tmp_app_file = db_name.replace(dex_db_dir, "")
                        app_name = tmp_app_file.replace(".db", "")
                        dotted_path = n_class.replace(".", "/")
                        file_name = ("decoded-*/%s/%s.smali"
                            % (app_name, dotted_path))

                    print file_name

                else:
                    print "\t%s" % (n_class)
                if show_fields:
                    fsql = ('SELECT sf.name '
                            'FROM static_fields sf '
                            'JOIN classes c '
                            'ON c.id=sf.class_id '
                            "WHERE c.name='%s'" % n_class)

                    for field_name in cursor.execute(fsql):

                        if field_name[0].find(field_contains) != -1:
                            print "\t  +%s" % field_name[0]

    # Class search related
    def do_class_search(self, dexdb, class_name, config):

        pass

    # String search related
    def do_string_search(self, dex_db, pattern):

        """Do string search in DB"""

        string_matches = list()

        string_list = dex_db.get_strings()
        if string_list is None:
            log.e(TAG, "Unable to search strings!")
            return -1

        for string in string_list:

            if re.search(pattern, string):
                string_matches.append(string)

        if len(string_matches) > 0:
            print "Match(es) in %s" % dex_db.get_db_name()
            for match in string_matches:
                print "  %s" % match

        return 0

    # Command related
    def cmd_search_class(self, args):

        """Search for class"""

        parser = ArgumentParser(prog=self.name,
                            description='Search for class.')
        parser.add_argument('class_name', help='Class to search for.',
                            default=None)
        parser.add_argument('-f', '--filter', dest='filters',
                            default=None,
                            help='Search in apps or frameworks.')

        parsed_args = parser.parse_args(args)

        string_matches = list()
        rtn = 0

        class_name = parsed_args.class_name
        filters = self.validate_filters(parsed_args.filters)

        if filters is None:
            log.e(TAG, "Unable to validate filters!")
            return -1

        db_dir = prop.get_prop("Local", "db-dir")

        app_dex_db_dir = "%s/%s/appdexdbs/" % (prop.TOP, db_dir)
        framework_dex_db_dir = "%s/%s/frameworkdexdbs/" % (prop.TOP, db_dir)

        # Do applications
        if FILTER_APPS in filters:

            print "Matches in applications:"

            if not os.path.isdir(app_dex_db_dir):
                log.e(TAG, "Application DEX DB dir doesn't exist!")
                return -2

            for db_path in self.get_valid_dbs(app_dex_db_dir):

                dex_db = DexDb.DexDb(db_path, safe=True)

                rtn |= self.do_class_search(dex_db, class_name, config)

        # Do frameworks
        if FILTER_FRAMEWORKS in filters:

            print "Matches in frameworks:"

            if not os.path.isdir(framework_dex_db_dir):
                log.e(TAG, "Framework DEX DB dir doesn't exist!")
                return -2

            for db_path in self.get_valid_dbs(framework_dex_db_dir):

                dex_db = DexDb.DexDb(db_path, safe=True)

                rtn |= self.do_class_search(dex_db, class_name, config)

        return rtn


    def cmd_search_field(self, args):

        """Search for field"""

        pass


    def cmd_search_method(self, args):

        """Search for method"""

        pass


    # TODO
    def cmd_search_string(self, args):

        """Search for a string"""

        parser = ArgumentParser(prog=self.name,
                            description='Search for strings.')
        parser.add_argument('search_pattern', help='Pattern to search for.',
                            default=None)
        parser.add_argument('-f', '--filter', dest='filters',
                            default=None,
                            help='Search in apps or frameworks.')

        parsed_args = parser.parse_args(args)

        string_matches = list()
        rtn = 0

        search_pattern = parsed_args.search_pattern
        filters = self.validate_filters(parsed_args.filters)

        if filters is None:
            log.e(TAG, "Unable to validate filters!")
            return -1

        # Make sure pattern is valid
        try:
            pattern = re.compile(search_pattern, re.UNICODE)
        except Exception as inst:
            log.e(TAG, "Unable to parse pattern: %s" % inst)
            return -2

        db_dir = prop.get_prop("Local", "db-dir")

        app_dex_db_dir = "%s/%s/appdexdbs/" % (prop.TOP, db_dir)
        framework_dex_db_dir = "%s/%s/frameworkdexdbs/" % (prop.TOP, db_dir)

        # Do applications
        if FILTER_APPS in filters:

            print "Matches in applications:"

            if not os.path.isdir(app_dex_db_dir):
                log.e(TAG, "Application DEX DB dir doesn't exist!")
                return -2

            for db_path in self.get_valid_dbs(app_dex_db_dir):

                dex_db = DexDb.DexDb(db_path, safe=True)

                rtn |= self.do_string_search(dex_db, pattern)

        # Do frameworks
        if FILTER_FRAMEWORKS in filters:

            print "Matches in frameworks:"

            if not os.path.isdir(framework_dex_db_dir):
                log.e(TAG, "Framework DEX DB dir doesn't exist!")
                return -2

            for db_path in self.get_valid_dbs(framework_dex_db_dir):

                dex_db = DexDb.DexDb(db_path, safe=True)

                rtn |= self.do_string_search(dex_db, pattern)

        return rtn

    def execute(self, args):

        """Main executor method"""

        if len(args) == 0:
            return self.usage()
        mode = args.pop(0)

        if mode in ['class', 'c']:
            return self.cmd_search_class(args)
        elif mode in ['field', 'f']:
            return self.cmd_search_field(args)
        elif mode in ['string', 's']:
            return self.cmd_search_string(args)
        elif mode in ['method', 'm']:
            return self.cmd_search_method(args)
        else:
            return self.usage()



        config = dict()
        class_name = None
        method_name = None

        parser = ArgumentParser(prog=self.name,
                            description='Search for a class name.')
        parser.add_argument('search_class', help='Class to search for.',
                            default=None)
        parser.add_argument('--frameworks', dest='fw', action='store_const',
                            const=True, default=False,
                            help='Search framework files.')
        parser.add_argument('--apps', dest='app', action='store_const',
                            const=True, default=False,
                            help='Search application files.')
        parser.add_argument('-e', dest='exact', action='store_const',
                            const=True, default=False,
                            help='Match exact name.')
        parser.add_argument('-f', dest='file_mode', action='store_const',
                            const=True, default=False,
                            help='Print path to file instead.')
        parser.add_argument('--hasMethod', dest='has_method',
                            help='Search by method name.')
        parser.add_argument('--hasString', dest='has_string',
                            help='Search for string matching pattern.')
        parser.add_argument('--implements', dest='implements', default=None,
                            help='Search by implemented class')
        parser.add_argument('--fields', dest='show_fields',
                            action='store_const', const=1, default=0,
                            help='Display fields for matching class')
        parser.add_argument('--methods', dest='show_methods',
                            action='store_const', const=1, default=0,
                            help='Display methods for matching class')
        parser.add_argument('--fieldContains', dest='field_contains',
                            default=None, help='Filter fields')

        parsed_args = parser.parse_args(args)

        search_frameworks = parsed_args.fw
        search_apps = parsed_args.app

        if search_frameworks == False and search_apps == False:
            log.e(TAG, "You must specify either '--frameworks' or '--apps'!")
            return -2

        method_name = parsed_args.has_method
        string_pattern = parsed_args.has_string
        class_name = parsed_args.search_class
        show_methods = parsed_args.show_methods
        show_fields = parsed_args.show_fields
        field_contains = parsed_args.field_contains
        exact = parsed_args.exact
        file_mode = parsed_args.file_mode

        config['method_name'] = method_name
        config['string_pattern'] = string_pattern
        config['class_name'] = class_name
        config['show_methods'] = show_methods
        config['show_fields'] = show_fields
        config['field_contains'] = field_contains
        config['file_mode'] = file_mode
        config['exact'] = exact

        if class_name is None and (method_name is None and string_pattern is None):
            log.e(TAG, "You need to specify a class_name to search for!")
            return -2

        db_dir = prop.get_prop("Local", "db-dir")

        if search_frameworks:
            config['mode'] = 'frameworks'
            try:
                for db_file in listdir(db_dir + "/frameworkdexdbs/"):
                    self.search_db(db_dir + "/frameworkdexdbs/" + db_file,
                                   config)
            except OSError:
                log.e(TAG, "Error listing framework DEX DBs, do they exist?")
                return -4

        if search_apps:
            config['mode'] = 'apps'
            try:
                for db_file in listdir(db_dir + "/appdexdbs/"):
                    self.search_db(db_dir + "/appdexdbs/" + db_file, config)
            except OSError:
                log.e(TAG, "Error listing app DEX DBs, do they exist?")
                return -4

